#!/usr/bin/env python3

import argparse
import os
import shutil
import socket
import subprocess
import tarfile
import time
import uuid

from io import BytesIO
from uuid import uuid4

import lxc

try:
    import raven
except ImportError:
    client = None
else:
    client = raven.Client()

DESCRIPTION = "LXC Wrapper for running Changes jobs"


class Container(lxc.Container):
    def __init__(self, project=None, snapshot=None, variant=None, release='precise',
                 image_mirror="images.linuxcontainers.org", validate=True, *args, **kwargs):
        self.project = project
        self.snapshot = snapshot
        self.release = release

        if variant is None and self.snapshot:
            self.variant = "{}-{}".format(project, snapshot)
        else:
            self.variant = variant

        # This will be the hostname inside the container
        self.utsname = self.variant if self.variant else self.project

        self.image_mirror = image_mirror
        self.validate = validate

        # Randomize container name to prevent clobbering
        super().__init__(str(uuid.uuid1()), *args, **kwargs)

    @property
    def rootfs(self):
        """ May be real path or overlayfs:base-dir:delta-dir """
        return self.get_config_item('lxc.rootfs').split(':')[-1]

    def run_script(self, script_path):
        if os.path.isfile(script_path) and not os.path.isfile(os.path.join(self.rootfs, script_path)):
            new_name = os.path.join("tmp", "script-{}".format(uuid4().hex))
            print(" ==> Writing local script {} as /{}".format(script_path, new_name))
            shutil.copy(script_path, os.path.join(self.rootfs, new_name))
            os.chmod(script_path, 755)
            script_path = '/' + new_name
        assert self.run([script_path]) == 0

    def run(self, cmd, cwd="/", env=None):
        assert self.running, "Cannot run cmd in non-RUNNING container"

        def run(args):
            cmd, cwd, env = args

            new_env = {
                'HOME': '/root',
                'DEBIAN_FRONTEND': 'noninteractive',
                'LXC_NAME': self.name,
                'HOST_HOSTNAME': socket.gethostname(),
                'PATH': '/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin',
            }
            if env:
                new_env.update(env)

            return subprocess.call(cmd, cwd=cwd, env=new_env)

        print(" ==> Running: {}".format(cmd))
        ret_code = self.attach_wait(run, (cmd, cwd, env), env_policy=lxc.LXC_ATTACH_CLEAR_ENV)
        print(" ==> Command exited: {}".format(ret_code))

        return ret_code

    def install(self, pkgs):
        return self.run(["apt-get", "install", "-y", "--force-yes"] + pkgs)

    def launch(self, pre=None, post=None, clean=False, flush_cache=False):
        """ Launch a container

        If we have a variant, attempt to download and extract the image to clone.
        Without a variant, generate a container from ubuntu minimal install.
        """

        if self.variant and not clean:
            if self.variant not in lxc.list_containers():
                create_args = [
                    '--server', self.image_mirror,
                    '--variant', self.variant,
                    '--dist', 'ubuntu',
                ]
                if not self.validate:
                    create_args.extend(['--no-validate'])

                print(" ==> Getting image: {}".format(self.variant))
                base = lxc.Container(self.variant)
                assert base.create('download', args=create_args), (
                    "Failed to download: {}".format(self.variant))
            else:
                base = lxc.Container(self.variant)

            print(" ==> Overlaying container: {}".format(self.variant))
            assert base.clone(self.name,
                              flags=lxc.LXC_CLONE_KEEPNAME | lxc.LXC_CLONE_SNAPSHOT), (
                "Failed to clone: {}".format(self.variant))
            assert self.load_config(), "Unable to reload container config"
        else:
            create_args = [
                '--release', self.release,
                '--arch', 'amd64',
            ]
            if flush_cache:
                create_args.extend(['--flush-cache'])

            print(" ==> Creating container")
            assert self.create('ubuntu', args=create_args), "Failed to create container"

        if pre:
            pre_env = dict(os.environ, LXC_ROOTFS=self.rootfs, LXC_NAME=self.name)
            subprocess.check_call(pre, cwd=self.rootfs, env=pre_env)

        # XXX: More or less disable apparmor
        assert self.set_config_item("lxc.aa_profile", "unconfined")
        # Allow loop/squashfs in container
        assert self.append_config_item('lxc.cgroup.devices.allow', 'c 10:137 rwm')
        assert self.append_config_item('lxc.cgroup.devices.allow', 'b 6:* rwm')

        print(" ==> Starting container")
        assert self.start(), "Failed to start base container"

        print(" ==> Waiting for container to startup networking")
        assert self.get_ips(family='inet', timeout=30), "Failed to connect to container"

        print(" ==> Install ca-certificates")
        assert self.install(["ca-certificates"]) == 0

        if post:
            # Naively check if trying to run a file that exists outside the container
            self.run_script(post)

    def create_image(self, expires=86400, dest="/tmp"):
        print(" ==> Create meta.tar")
        with tarfile.open(os.path.join(dest, "meta.tar"), "w:") as meta_tar:
            content = "{}\n".format(int(time.time() + expires))
            expiry = tarfile.TarInfo("expiry")
            expiry.size = len(content)
            expiry.mtime = int(time.strftime("%s", time.localtime()))
            meta_tar.addfile(expiry, BytesIO(content.encode('utf-8')))

            lines = [
                "lxc.include = LXC_TEMPLATE_CONFIG/ubuntu.common.conf",
                "lxc.arch = x86_64",
            ]
            content = "\n".join(lines)
            config = tarfile.TarInfo("config")
            config.size = len(content)
            config.mtime = int(time.strftime("%s", time.localtime()))
            meta_tar.addfile(config, BytesIO(content.encode('utf-8')))

        meta_txz = os.path.join(dest, "meta.tar.xz")
        rootfs_txz = os.path.join(dest, "rootfs.tar.xz")

        print(" ==> Create meta.tar.xz")
        if os.path.exists(meta_txz):
            os.remove(meta_txz)
        subprocess.check_call(["xz", "-9", meta_tar.name])

        print(" ==> Stopping container")
        self.stop()

        assert self.wait('STOPPED', timeout=30)

        print(" ==> Creating rootfs.tar.xz")
        subprocess.check_call(["tar", "-Jcf", rootfs_txz,
                               "-C", self.get_config_item('lxc.rootfs'),
                               "."])

        with open(os.path.join(dest, "snapshot_id"), 'w') as fp:
            fp.write(self.utsname)

        return (self.name, meta_txz, rootfs_txz)

    def destroy(self, timeout=-1):
        if not self.defined:
            print(" ==> No container to destroy")
            return

        if self.running:
            print(" ==> Container is running, stop it first")
            self.stop()
            print(" ==> Wait for container to stop")
            self.wait('STOPPED', timeout=timeout)

        print(" ==> Destroying container")
        super().destroy()


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description=DESCRIPTION)
    parser.add_argument('--project', '-p', required=True,
                        help="Name of project for the container")
    parser.add_argument('--snapshot', '-s',
                        help="Snapshot ID of the container")
    parser.add_argument('--variant',
                        help="Explicit ID of container image to use")
    parser.add_argument('--release', '-r', default='precise',
                        help="Ubuntu release (default: %(default)s)")
    parser.add_argument('--keep', action='store_true', default=False,
                        help="Don't destroy the container after running cmd/build")
    parser.add_argument('--image-mirror', default="images.linuxcontainers.org",
                        help="Base URL of where container images are stored (default: %(default)s)")
    parser.add_argument('--no-validate', action='store_false', default=True, dest='validate',
                        help="Don't validate downloaded images")
    parser.add_argument('--save-snapshot', action='store_true', default=False,
                        help="Create an image from this container")
    parser.add_argument('--clean', action='store_true', default=False,
                        help="Use a fresh container from Ubuntu minimal install")
    parser.add_argument('--flush-cache', action='store_true', default=False,
                        help="Rebuild Ubuntu minimal install cache")
    parser.add_argument('--api-url',
                        help="API URL to Changes")
    parser.add_argument('--jobstep-id',
                        help="Jobstep ID for Changes")
    parser.add_argument('--pre-launch',
                        help="Command to run before container is launched")
    parser.add_argument('--post-launch',
                        help="Command to run after container is launched")
    parser.add_argument('--script',
                        help="Script to execute as command")
    parser.add_argument('cmd', nargs=argparse.REMAINDER,
                        help="Command to run inside the container")

    args = parser.parse_args()

    try:
        args.cmd.remove('--')
    except ValueError:
        pass

    container = Container(args.project, args.snapshot, args.variant, args.release,
                          args.image_mirror, args.validate)
    try:
        container.launch(args.pre_launch, args.post_launch, args.clean, args.flush_cache)

        # TODO(dcramer): we should assert only one type of command arg is set
        if args.cmd:
            container.run(args.cmd)
        if args.script:
            container.run_script(args.script)
        if args.api_url and args.jobstep_id:
            container.run(['changes-client',
                           '--server', args.api_url,
                           '--jobstep_id', args.jobstep_id])
        if args.save_snapshot:
            container.create_image(dest=os.getcwd())
    except Exception as e:
        if client:
            client.captureException()
        raise e
    finally:
        if not args.keep:
            container.destroy()
        else:
            print(" ==> Container kept at {}".format(container.rootfs))
            print(" ==> SSH available via:")
            print(" ==>   $ sudo lxc-attach --name={}".format(container.name))
